(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{466:function(t,r,v){t.exports=v.p+"assets/img/1.050ec4e1.png"},467:function(t,r,v){t.exports=v.p+"assets/img/2.63ea225a.png"},468:function(t,r,v){t.exports=v.p+"assets/img/3.cfc2fcbf.png"},469:function(t,r,v){t.exports=v.p+"assets/img/4.8fb185c3.png"},542:function(t,r,v){"use strict";v.r(r);var _=v(18),e=Object(_.a)({},(function(){var t=this,r=t.$createElement,_=t._self._c||r;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"c"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#c"}},[t._v("#")]),t._v(" C#")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("是一種型別安全 (Type-safe) 的物件導向 (object-oriented) 程式語言 (Programming Language)")])]),t._v(" "),_("li",[_("p",[t._v("這裡的型別安全泛指所有的 C# 物件都是具有型別的，例如 Int32, String, StringBuilder, … 等等都是型別，在各型別的繼承關係中，最上層的型別為 object")])]),t._v(" "),_("li",[_("p",[t._v("C# 含一套編譯器，將C#程式碼編譯為 .NET中繼語言 ( IL ) (Intermediate language)，執行檔為 csc.exe")])]),t._v(" "),_("li",[_("p",[t._v("C# 編譯器在編譯時，可以透過 /langversion 參數指定編譯版本，目前支援 ISO-1、ISO-2、3、4、5 等版本。")])]),t._v(" "),_("li",[_("p",[t._v("C# 6.0 開始，採用全新的 Roslyn 編譯器平台，跟傳統編譯器的架構差別非常大，且編譯器本身開放原始碼。")])]),t._v(" "),_("li",[_("p",[t._v("C# 6.0 的 csc.exe 編譯器改由 NuGet 進行安裝，如需在專案中使用 C# 6.0 語法，則需額外安裝 Microsoft.CodeDom.Providers.DotNetCompilerPlatform 套件。")])]),t._v(" "),_("li",[_("p",[t._v("在開發應用程式的時候又有區分「強型別」與「弱型別」的開發方式。")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("強型別")]),t._v("：存取物件資料時，不需要額外轉型的開發方法，凡事都用明確的型別來表達與傳遞資料。")]),t._v(" "),_("li",[_("strong",[t._v("弱型別")]),t._v("：存取物件資料時，用較為抽象的型別來保存資料，需要用到資料時再透過轉型得到真正的型別。\n"),_("img",{attrs:{src:v(466),alt:""}})])])]),t._v(" "),_("li",[_("p",[t._v("程式語言都有「語言特性」，有些 C# 的語言特性會需要用到 .NET Framework 的特定類別，因此 C# 通常會與 .NET Framework 有版本的相依性。")])])]),t._v(" "),_("hr"),t._v(" "),_("h3",{attrs:{id:"型別補充"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#型別補充"}},[t._v("#")]),t._v(" "),_("strong",[t._v("型別補充")])]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("強型別")]),t._v("與"),_("strong",[t._v("弱型別")]),t._v(":\n不同型別在"),_("strong",[t._v("變數賦值")]),t._v("時,是否需要進行型別轉換\n"),_("ul",[_("li",[t._v("強型別語言需要顯式型別轉換,")]),t._v(" "),_("li",[t._v("弱型別語言不需要顯式的型別轉換。")])])]),t._v(" "),_("li",[_("strong",[t._v("動態型別")]),t._v("和"),_("strong",[t._v("靜態型別")]),t._v("區別:\n"),_("ul",[_("li",[t._v("執行時檢查[動態]")]),t._v(" "),_("li",[t._v("編譯期檢查[靜態]")])])])]),t._v(" "),_("p",[_("strong",[t._v("靜態型別")]),t._v("提供多個重要的優點")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("安全性")]),t._v(":編譯時就能檢查所有使用到相同變數名稱的地方是否如預期擁有完整的型別資訊")]),t._v(" "),_("li",[_("strong",[t._v("效能")]),t._v(":動態型別在執行期間，需檢查每個變數的型別及該變數在哪些函式出現，對執行環境是一個重大的開銷，對靜態型別語言而言這是不需要的。這也是多數傳統動態語言如 Python執行速度較其他靜態型別語言慢的部分原因")]),t._v(" "),_("li",[_("strong",[t._v("可維護性")]),t._v(":靜態方式宣告變數，程式較容易理解維護")])]),t._v(" "),_("p",[t._v("過去十年加入的主要語言像是 Go、Swift全是"),_("strong",[t._v("靜態型別")]),t._v("\nApple 選擇用"),_("strong",[t._v("Swift")]),t._v("取代動態型別的"),_("strong",[t._v("Objective-C")]),t._v("也是隨著這趨勢。")]),t._v(" "),_("hr"),t._v(" "),_("h2",{attrs:{id:"net"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#net"}},[t._v("#")]),t._v(" .Net")]),t._v(" "),_("p",[t._v("C#所開發的程式原始碼並不是編譯成能夠直接在作業系統上執行的二進位制原生代碼。它是被編譯成為中間程式碼IL程式碼,然後IL程式碼通過.NET框架的虛擬機器（即CLR）來翻譯成為二進位制機器碼，從而使它得到正確的執行。最終翻譯的二進位制程式碼將被儲存在一個緩衝區中。所以一旦程式使用了相同的程式碼，那麼將會呼叫緩衝區中的版本。這樣如果一個.Net程式第二次被執行，那麼這種翻譯不需要進行第二次，速度會明顯加快。")]),t._v(" "),_("p",[_("img",{attrs:{src:v(467),alt:""}})]),t._v(" "),_("h3",{attrs:{id:"clr-common-language-runtime"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#clr-common-language-runtime"}},[t._v("#")]),t._v(" "),_("strong",[t._v("CLR ( Common Language Runtime )")])]),t._v(" "),_("ul",[_("li",[t._v("CLR 是 .NET Framework 的虛擬機器元件 (virtual machine component)，用來管理執行中的 .NET 程序。")]),t._v(" "),_("li",[t._v("CLR 有個重要的流程是 JIT 編譯 (just-in-time compilation) 機制，可以將 .NET 程式編譯過的中繼語言 (Intermediate language) 編譯為當前 CPU 架構可執行的機器碼 (machine instructions)。")]),t._v(" "),_("li",[t._v("CLR 提供記憶體管理、型別安全、例外處理、垃圾回收機制 (GC)、安全性、執行緒管理等服務。\n無論什麼程式語言，只要是基於 .NET 框架的程式，都必須執行於 CLR 提供的執行環境(虛擬機器)中。")]),t._v(" "),_("li",[t._v("CLR 包含一系列 基礎類別函式庫 (BCL) ( Base Class Libraries )，用來提供 .NET 執行時期需要的程式基礎。\n在該函式庫中含有一堆 組件 (Assembly) 與 型別 (Type) 定義，如命名空間、類別、介面、列舉、… 等等。")])]),t._v(" "),_("h3",{attrs:{id:"net-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#net-2"}},[t._v("#")]),t._v(" "),_("strong",[t._v(".NET")])]),t._v(" "),_("ul",[_("li",[t._v(".NET Framework 的簡稱，有時候泛指 .NET 相關的各種技術。")]),t._v(" "),_("li",[t._v(".NET Framework 包含一系列 框架類別函式庫 ( FCL ) ( Framework Class Libraries )，用來擴充 BCL 不足的地方。")])]),t._v(" "),_("h2",{attrs:{id:"mono"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mono"}},[t._v("#")]),t._v(" "),_("strong",[t._v("Mono")])]),t._v(" "),_("p",[t._v("但.net framework因為特定的依賴是能在windows上執行，於是Mono為了跨平臺就誕生了")]),t._v(" "),_("ul",[_("li",[t._v("Mono就作為一個中間層將IL程式碼的處理分出好多個分支,分別對應不同的平臺")]),t._v(" "),_("li",[t._v("Mono其實和.net framework 是同一個東西,只不過Mono支援更多的平臺,但.Net的執行效率更高")])]),t._v(" "),_("h2",{attrs:{id:"微軟開發全新的-net-core-framework"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#微軟開發全新的-net-core-framework"}},[t._v("#")]),t._v(" "),_("strong",[t._v("微軟開發全新的.NET Core Framework")])]),t._v(" "),_("p",[t._v("微軟在Windows平臺上的.NET Framework的實現最為完整，但是.NET Framework和windows作業系統有很深的繫結，難以跨平臺。Mono專案在.NET 的基礎類庫實現上有一些不夠完美。隨後在.NET開源基金會的統一規劃下誕生了.NET Core 。")]),t._v(" "),_("h2",{attrs:{id:"什麼是il2cpp"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什麼是il2cpp"}},[t._v("#")]),t._v(" "),_("strong",[t._v("什麼是IL2CPP")]),t._v("?")]),t._v(" "),_("p",[t._v("在了解IL2CPP前先來講講什麼是"),_("strong",[t._v("IL")])]),t._v(" "),_("h3",{attrs:{id:"il"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#il"}},[t._v("#")]),t._v(" "),_("strong",[t._v("IL")])]),t._v(" "),_("ul",[_("li",[_("p",[t._v("IL的全稱是 Intermediate Language")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("CIL")]),t._v("（Common Intermediate Language，特指在.Net平臺下的IL標準）。在Unity中,IL和CIL表示的是同一個東西：翻譯過來就是中間語言。")])]),t._v(" "),_("li",[_("p",[t._v("一種屬於通用語言架構和.NET框架的低階（lowest-level）的"),_("strong",[t._v("人類可讀")]),t._v("的程式語言")])]),t._v(" "),_("li",[_("p",[t._v("目標為.NET框架的語言被編譯成CIL，然後彙編成位元組碼")])]),t._v(" "),_("li",[_("p",[t._v("CIL類似一個物件導向的組合語言，並且它是完全基於堆疊的，它執行在虛擬機器上（.Net Framework, Mono VM）的語言")])]),t._v(" "),_("li",[_("p",[t._v("具體過程是：C#或者VB這樣遵循CLI規範的高階語言，被先被各自的編譯器編譯成中間語言：IL（CIL），等到需要真正執行的時候，這些IL會被載入到執行時庫，也就是VM中，由VM動態的編譯成彙編程式碼（JIT,Just-In-Time即時編譯）然後在執行。\n"),_("img",{attrs:{src:v(468),alt:""}})])]),t._v(" "),_("li",[_("p",[t._v("本質上說，到了IL這一層級，它是由哪個高階語言建立的已經不重要了，你可以用C#，VB，Boo，Unity Script甚至C++，只要有相應的編譯器能夠將其編譯成IL都行！")])])]),t._v(" "),_("hr"),t._v(" "),_("h3",{attrs:{id:"轉譯方式補充"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#轉譯方式補充"}},[t._v("#")]),t._v(" "),_("strong",[t._v("轉譯方式補充")])]),t._v(" "),_("ul",[_("li",[t._v("即時編譯（Just in time,JIT）：程序運行過程中，將CIL的byte code轉譯為目標平台的原生碼。")]),t._v(" "),_("li",[t._v("提前編譯（Ahead of time,AOT）：程序運行之前，將.exe或.dll文件中的CIL的byte code部分轉譯為目標平台的原生碼並且存儲，程序運行中仍有部分CIL的byte code需要JIT編譯。")]),t._v(" "),_("li",[t._v("完全靜態編譯（Full ahead of time,Full-AOT）：程序運行前，將所有源碼編譯成目標平台的原生碼。")])]),t._v(" "),_("hr"),t._v(" "),_("h3",{attrs:{id:"il2cpp"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#il2cpp"}},[t._v("#")]),t._v(" "),_("strong",[t._v("IL2CPP")])]),t._v(" "),_("p",[t._v("有了上面的知識，就容易理解：把IL中間語言轉換成CPP檔案。\n"),_("img",{attrs:{src:v(469),alt:""}})]),t._v(" "),_("ul",[_("li",[t._v("AOT編譯器將IL轉換為C++源代碼")]),t._v(" "),_("li",[_("strong",[t._v("提高執行效率")]),t._v("\n根據官方的實驗資料，換成IL2CPP以後，程式的執行效率有了1.5-2.0倍的提升。")])])])}),[],!1,null,null,null);r.default=e.exports}}]);